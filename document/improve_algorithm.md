# アルゴリズム設計案（言語非依存な説明）

以下のアルゴリズムは、どのプログラミング言語でも実装できる形で説明します。

## 前提

- **センサーデータ取得間隔**: 200ms（サンプリング間隔）
- **ローパスフィルタ**: センサーのノイズを抑制するために利用
- **ステップ検出**: フィルタ後の加速度変化の大きさを利用して、一定の閾値を超えた場合に歩数をカウント

## アルゴリズム

### 初期化

```
prevFiltered ← (0, 0, 0) // 各軸の初期フィルタ値
lastStepTime ← 0 // 最後に歩数をカウントしたタイムスタンプ（ミリ秒など）
定数 ALPHA ← 0.8 // ローパスフィルタの係数
定数 THRESHOLD ← 適切な値（例: 1.0 など、実験的に調整）
定数 MIN_STEP_INTERVAL ← 300ms // 連続検出を防ぐための最小間隔
```

### センサーデータ受信時の処理（各サンプル毎に実行）

1. **現在の加速度 A_current を取得**
   - $$ A_current = (ax, ay, az) $$

2. **ローパスフィルタ適用**
   - 各軸ごとに計算する：
   ```
   filtered = ALPHA * prevFiltered + (1 - ALPHA) * A_current
   ```

3. **変化量の計算**
   ```
   delta = √((filtered.x - prevFiltered.x)² + (filtered.y - prevFiltered.y)² + (filtered.z - prevFiltered.z)²)
   ```

4. **ステップ検出判定**
   - 現在時刻を $$ T_current $$ とする。
   - もし $$ delta > THRESHOLD $$ かつ $$ T_current - lastStepTime > MIN_STEP_INTERVAL $$ ならば：
     1. **ステップ数を 1 増加**
     2. **lastStepTime を T_current に更新**

5. **更新**
   ```
   prevFiltered = filtered
   ```

## 補足

- **歩数補正係数の適用**
  - 最終的なカウント値に対して乗算するか、または検出時の条件に組み込む（例：ユーザー毎に閾値を調整）。
- **より正確な歩数計測**
  - 加速度の変化だけでなく、ピーク検出や状態遷移（上昇局面と下降局面の検出）を導入することで、精度を向上可能。

## このアルゴリズムの特徴

1. **フィルタ処理と差分計算の正しい順序**
   - 前回のフィルタ値と今回のフィルタ値の差分を正しく計算するため、差分計算後に前回値を更新。

2. **連続カウント防止**
   - **一定の間隔（例：300ms）を設ける**ことで、1回の歩行動作につき複数回カウントされるのを防ぐ。

3. **パラメータの調整性**
   - $$ THRESHOLD $$ や $$ MIN_STEP_INTERVAL $$ は実機での検証を通じて調整可能にしており、ユーザーやデバイス特性に合わせた補正が容易。
